# C++ template metaprogramming
#### 1. what's the spirit of metaprogramming

#### 2. Template parameters
##### 2.1 value parameter
##### 2.2 type parameter
##### 2.3 template template parameter

#### 3. function templates

#### 4. class templates
##### 4.1 template type alias
##### 4.2 using class members that are types

#### 5. Template compilation
##### 5.1 Controlling Instantiations

#### 6. Template Argument Deduction

#### 7. Variadic Templates
##### 7.1 `sizeof...` operator
##### 7.2 writing a variadic function template
##### 7.3 Pack expansion

#### 8. Template Specializations
##### 8.1 defining a function template specialization
##### 8.2 function overloading versus template specializations
##### 8.3 class template specializations
##### 8.4 class-template partial specializations
##### 8.5 specializing members but not the class

#### 1 spirit of metaprogramming
**All in one, template metaprogramming is all about types and works in compile time**.

Normally, programmers write code that is compiled and does something at run-time. While metaprogrammars write code that generates code at complile-time. Metaprogrammers use **metafunctions** to describe the code that generates code. That is, a function that takes types or non-type parameters as parameters and return a new type.

Template metaprogramming consists in **using the C++ template system to generate C++ types, and C++ code at compile-time**. A template function or class is not a function or class at all. It's a template to generate functions or classes. After instantiating the template with some types as argument, we get a new type or instance.

Take *std::vector* as an example. std::vector is not a class, is a template. We can instantiate std::vector with different element types to get new types. *`std::vector<int>`* is a new class type, *`std::vector<string>`* is another new class type, *`std::vector<double>`* is another new. These three new class types are generated by compiler at compile-time according to the *`std::vector`* template and managed internally by the compiler.

As metaprogramming, we actually work with C++ type system, using types as values for our computations. What's more, template metaprogramming works like a *functional programming language*. Because metafunctions have no side effect: **we can only create new types, not to modify existing ones**.

See [Introduction](http://blog.biicode.com/template-metaprogramming-with-modern-cpp-introduction/)

#### 2. Template parameters
C++ templates can take three kinds of parameters: **Value parameters**, **type parameters**, and **template template parameter**.

##### 2.1 value parameters
For value parameters (nontype parameters), C++ templates can only take parameters that are values known at compile time - constant expression. A nontype parameter may be an integral type, or a pointer, or reference to an object, or to a function type. An argument bound to a nontype integral parameter must be a constant expresion.

##### 2.2 type parameters
In general, we can use a type parameter as a type specifier in the same way that we use a built-in or class type specifier. In particular, a type parameter can be used to name the return type or a function parameter type, and for variable declarations or casts inside the function body.

##### 2.3 template template parameter
See [Template metaprogramming](http://blog.biicode.com/template-metaprogramming-cpp-ii/)

#### 3. Function templates
A function template can be declared *`inline`* or *`constexpr`* in the same way as nontemplate functions. The *`inline`* or *`constexpr`* specifier follows the template parameter list and precedes the return type:
```c++
template <typename T> inline T func(const T&);
```

#### 4. class templates
Class templates differ from function templates in that the **compiler cannot deduce the template parameter types for a class template**. Remember **the name of a class template is not the name of a type. A class template is used to instantiate a type, and an instantiated type always includes template argument(s)**.

By default, a member of an instantiated class template is instantiated only if the member is used. **The fact that members are instantiated only if we use them lets us instantiate a class with a type that may not meet the requirements for some of the template's operations**.

When we are inside the scope of a class template, the compiler treats references to the template itself as if we had supplied template arguments matching the template's own parameters.
```c++
template<typename T>
class Cla
{
public:
    Cla& operator++();
}
```
When we define members outside the body of a class template, we must remember that we are not in the scope of the class until the class name is seen. Inside the function body, we are in the scope of the class so do not need to repeat the template argument. When we do not supply template arguments, the compiler assumes that we are using the same type as the member's instantiation.
```c++
template<typename T>
Cla<T> Cla<T>::operator++(int)
{
    Cla ret = *this;
    ++*this;
    return ret;
}
```

##### 4.1 Template Type Alias
An instantiation of a class template defines a class type, and as with any other class type, we can define a `typedef` that refers to that instantiated class:
```C++
typedef Cla<int> IntCla;
```

Because a template is not a type, we cannot define a `typedef` that refers to a template.

However, we can use the following to define a type alias for a class template:
```C++
template<typename T> using twin = std::pair<T, T>;
typedef twin<int> IntPoint;     // IntPoint is a synonym for std::pair<int, int>
IntPoint p;

// std::vector is a template, std::vector<T>::size_type is a type.
typedef typename std::vector<T>::size_type SizeType;
SizeType index = SizeType();
```

When we define a template type alias, we can fix one or more of the template parameters:
```C++
template <typename T> using PartNo = std::pair<T, int>;
PartNo<string> books;       // books is a std::pair<string, int>
PartNo<Student> scores;     // scores is a std::pair<Student, int>
```

Note: template declarations must be in global, namespace or class scope, can't be in function scope.

##### 4.2 Using class members that are types
We can use scope operator (`::`) to access both *static members* and *type members*. In nontemplate code, the compiler has access to the class definition. As a result, it knows whether a name accessed through the scope operator is a type or a static member. For example when we write `std::string::size_type`, the compiler has the definition of `std::string` and can see that `size_type` is a type.

Assuming `T` is a template type parameter, when the compiler sees code such as `T::mem` it won't know until instantiation time whether `mem` is a type or a `static` data memeber. However, in order to process the template when no instantiations, the compiler must know whether a name represents a type. For example:
```C++
T::size_type* p;
```
Assuming `T` is the name of a type parameter, when the compiler sees a statement of that, it needs to know whether we're defining a variable named `p` or are multiplying a `static` data member named `size_type` by a variable named `p`.

By default, a name accessed through the scope operator (`::`) is not a type. As a result, if we want to use a type member of a template type parameter, we must explicitly tell the compiler that the name is a type using `typename`, not `class`. For example:
```C++
typename T::size_type *p;
```
We are defining a variable named `p`.

#### 5. Template compilation
When the compiler sees the definition of a template, it does not generate code. It generates code only when we instantiate a specific instance of the template. To generate an instantiation, the compiler needs to have the code that defines a function template or class template member function. **So definitions of function templates and member functions of class templates are ordinarily put into header files.**

**Compilation errors of templates are mostly reported during instantiation**

##### 5.1 controlling instantiations
The fact that instantiations are generated when a template is used means that the same instantiation may appear in multiple object files. When two or more separately compiled source files use the same template with the same template arguments, there is an instantiation of that template in each of those files. Then there is overhead of instantiating the same template in multiple files.

We can avoid this overhead through an **explicit instantiation**. An explicit instantiation contains two aspects: **instantiation declaration** and **instantiation definition**.
```C++
extern template declaration;    // instantiation declaration
template declaration;           // instantiation definition
```

```C++
extern template class Foo<int>; // instantiation declaration
extern template int compare(const int&, const int&); // instantiation declaration
```

When the compiler sees an `extern` template declaration, it willn't generate code for that instantiation in that file. Delcaring an instantiation as `extern` is a promise that there will be a nonextern use of that instantiation elsewhere in the program.

Because the compiler automatically instantiates a template when we use it, the `extern` declaration must appear before any code that uses that instantiation.

```C++
template class Foo<int>;    // instantiation definition
template int compare(const int&, const int&); // instantiation definition
```
When the compiler sees an instantiation definition, it generates code.

An **instantiation definition** for a class template instantiates **all** the members of that template including inline member functions. When the compiler see an instantiation definition it cannot know which member functions the program uses (the usage is in other source files). Hence, unlike the way the compiler handles ordinary class template instantiations, the compiler instantiates **all** the members of that class. Even if we do not use a member, that member will be instantiated. Consequently, we can use explicit instantiation **only for types that can be used with all the members of that template**

#### 6. Template Argument Deduction
The process of determining the template arguments from the function arguments is known as **template argument deduction**. During template argument deduction, the compiler uses types of the arguments in the call to find the template arguments that generate a version of the function that best matches the given call.

##### 6.1 conversions and template type parameters
Top-level consts (indicate that an object itself is `const`) in either the paramter or the argument are ignored. The only other conversions performed in a call to a function template are:

**`const` conversions**: A function parameter that is a reference (or pointer) to a `const` can be passed a reference(or pointer) to a nonconst object.

**Array-or function-to-pointer conversions**: If the function parameter is not a reference type, then the normal pointer conversion will be applied to arguments of array or function type. An array argument will be converted to a pointer to its first element. Similiarly, a function argument will be converted to a pointer to the function's type.

Other conversions, such as the arithmetic conversions, derived-to-base, and user-defined conversions are not performed.

```C++
template<typename T> T fobj(T, T);      // non-reference, arguments are copied.
template<typename T> T fref(const T&, const T&);    // reference

string s1("value1");
const string s2("value2");
const string s3("value3");

// calls fobj(string, string); const is ignored. 
// Even though type of s1 (string) and s2 (const string) don't match exactly
// In the call to fobj, arguments are copied, 
// whether the original object is const doesn't matter.
fobj(s1, s2);

// calls fobj(string, string); const is ignored.
fobj(s2, s3);

// calls fref(const string&, const string&)
// use permissible conversion to const on s1.
fref(s1, s2);

// arrays with different sizes have different types.
// a: int[10], b: int[12]
int a[10], b[12];

// calls fobj(int*, int*). Both arrays are converted to pointer type int*
fobj(a, b);

// error, array types don't match
// when the parameter is a reference, the arrays are not converted to pointers
fref(a, b);
```

A function template can have parameters that are defined using ordinary types - types that don't involve a template type parameter. Normal conversions are applied to those arguments whose type is not a template parameter.

##### 6.2 function-template explicit arguments
```C++
template <typename T1, typename T2, typename T3>
T1 sum(T2, T3);
```

In this case, there is no argument whose type can be used to deduce the type of `T1`. The caller must provide an **explicit template argument** for this parameter.

```C++
// this call explicitly specified the type for T1 
// The compiler will deduce the types for T2 and T3 from the type of 23 and 15L.
auto val = sum<long>(23, 15L);
```

Normal conversions also apply for arguments whose template type parameter is explicitly specified.
```C++
// fobj(23, 15L) is an error
fobj<long>(23, 15L);
```

##### 6.3 Trailing return types and type transformation
For example, we might want to write a function that takes a pair of iterators denoting a sequence and returns a reference to an element in the sequence:
```C++
template<typename It>
???& func(It begin, It end)
{
    // process the range
    return *begin;
}
```
But we don't know the exact type we want to return. We can't use `decltype(*begin)` to replace the placeholder `???`. Because `begin` has not been seen when we use `decltype(*begin)`. To define this function, we must use a **trailing return type**.
```C++
// a trailing return lets us declare the return type after the parameter list is seen.
template<typename It>
auto func(It begin, It end) -> decltype(*begin)
{
    // process the range
    return *begin;
}
```

##### 6.4 function pointers and argument deduction
When we initialize or assign a function pointer from a function template, the compiler uses the type of the pointer to deduce the template arguments.

For example, we have a function pointer declared following:
```C++
int (*pf1)(const int&, const int&);

template<typename T> int compare(const T&, const T&);
```

And we have an assignment:
```C++
pf1 = compare;
```

The type of the parameters in `pf1` determines the type of the template argument for `T` which is `int`. The function pointer `pf1` points to the instantiation of `compare` with `T` bound to `int`.

##### 6.5 template argument deduction and reference
Let's analysis the type deduction from a call to a function template:
```C++
template<typename T> void func(T &p);
```
In which the function's parameter `p` is a reference to a template type parameter `T`. Remind there is no `const` before `T`, so `const` is low level.

###### 6.5.1 type deduction from lvalue reference function parameters
```C++
template<typename T> void func1(T&); // argument must be a lvalue

int i = 0; const int ci = 1;
// calls to func1 use the referred-to type of the argument as the template parameter type.
func1(i);    // i is an int; template parameter T is int
func1(ci);   // ci is an const int; template parameter T is const int
func1(5);    // error: argument to a & parameter must be a lvalue.
```
When a function parameter is an ordinary (lvalue) reference to a template type parameter (that has the form T&), the binding rules say that we can pass **only a lvalue**. That argument might or might not have a `const` type. If the argument is `const`, then `T` will be deduced as a `const` type.

```C++
template<typename T> void func2(const T&); // can take a rvalue

int i = 0; const int ci = 1;
// parameter in func2 is const &; const in the argument is irrelevant
// in each of these three calls, func2's function parameter type is inferred as const int&
func2(i);    // i is an int; template parameter T is int
func2(ci);   // ci is an const int; but template parameter T is int
func2(5);    // a const & parameter can be bound to a rvalue; T is int
```
When a function parameter has type `const T&`, normal binding rules say that we can pass any kind of argument - an object(const or otherwise), a temporary, or a literal value. When the function parameter is itself `const`, the type deduced for `T` will not be a `const` type. The `const` is already part of the function parameter type; therefore, it does not also become part of the template parameter type.

###### 6.5.2 type deduction from rvalue reference function parameters and reference collapsing.
```C++
template<typename T> void func3(T&&);

int i = 0; const int ci = 1;

// argument is a lvalue, template parameter T is int&
// void func3<int&>(int& &&);
// function parameter is int& &&, collapse to int&
func3(i);

// argument is a lvalue, template parameter T is const int&
// void func3<const int&>(const int& &&);
// function parameter is const int& &&, collapse to const int&
func3(ci);

// argument is an rvalue of type int, template parameter T is int.
func3(5);
```
For `func3(i)`, normally we cannot bind a rvalue reference to a lvalue. However there are two exceptios to normal binding rules that allow this kind of usage.

The first exception: when we pass a lvalue (e.g `i`) to a function parameter that is a rvalue reference to a template type parameter (e.g `T&&`), the compiler **deduces the template type parameter as the argument's lvalue reference type**. So, when we call `func3(i)`, the compiler deduces the type of `T` as `int&`, not `int`.

Deducing `T` as `int&` would seem to mean that `func3`'s function parameter would be a rvalue reference to the type `int&`. Ordinaryly, we cannot(directly) define a reference to a reference. However, it's possible to do so indirectly through a **type alias** or through a **template type parameter**.

The second exception: If we indirectly create a reference to a reference, then those references collapse. That is, for a given type `X`:

* `X& &`, `X& &&` and `X&& &` all collapse to type `X&`

* `X&& &&` collapses to `X&&`

Then we can have two important consequences from these rules:

* a function parameter that is a rvalue reference to a template type parameter(`T&&`) can be bound to a lvalue;

* If the argument is a lvalue, then the deduced template argument type will be a lvalue reference type and the function parameter will be instantiated as a lvalue reference parameter(`T&`)

So an argument of any type can be passed to a function parameter that is a rvalue reference to a template parameter type(`T&&`).

###### 6.5.3 Template functions with rvalue reference parameters

```C++
template<typename T> void func4(T&& val)
{
    T t = val;  // copy or binding a reference?
    t = fcn(t); // does the assignment change only t or val and t?
    if (val == t) {} // always true if T is a reference type.
}
```
When `func4` is called on rvalue, such as the literal `2`, `T` is `int`. In this case, the local variable `t` has type `int` and is initialized by copying the value of parameter `val`. When we assign to `t`, `val` remains unchanged.

But when `func4` is called on lvalue, then `T` is `int&`. When we define and initialize the local variable `t`, `t` has the type `int&`. The initialization of `t` binds `t` to `val`. In this initialization of `func4`, the `if` test always returns yield `true`.

In practice, rvalue reference parameters are used in the two contexts:

* the template is forwarding its arguments
* the template is overloaded.

###### 6.6 std::move

We cannot directly bind a rvalue reference to a lvalue, we can use `std::move` to obtain a rvalue reference bound to a lvalue.
```C++
template<typename T>
typename std::remove_reference<T>::type&& move(T&& t)
{
    static_cast<typename std::remove_reference<T>::type&&>(t);
}
```

```C++
string s1("hello"), s2;
s2 = std::move(string("world"));// moving from a rvalue
// moving from lvalue, assignment from rvalue reference has move semantic.
// after assignment, s1 has indeterminate value
s2 = std::move(s1);
```
In the first assignment, the argument to `move` is the rvalue result of the `string` constructor, `string("world")`. So in `std::move(string("world"))`:

* The deduced type of `T` is `string`
* Therefore, `remove_reference` is instantiated with `string`
* The `type` member of `remove_reference<string>` is `string`
* The return type of `move` is `string&&`
* `move`'s function parameter, `t` has type `string&&`
* The body of this function returns `static_cast<string&&>(t)` with t is type of `string&&`, so `static_cast` does nothing

So, the call `std::move(string("world"))` instantiates the following function:
```C++
string&& move(string&& t);
```

In the second assignment, the argument to `move` is a lvalue. So in `std::move(s1)`:

* The deduced type of `T` is `string&` (reference to string), see the first exception
* Therefore, `remove_reference` is instantiated with `string&`
* The `type` member of `remove_reference<string&>` is `string`
* The return type of `move` is still `string&&`
* `move`'s function parameter, `t`, instantiates as `string& &&`, which collapses to `string&`
* The body of this function returns `static_cast<string&&>(t)` with `t` is type of `string&`

So, the call `std::move(s1)` instantiates the following function:
```C++
string&& move(string& t);
```
This is what we want: we want to bind a rvalue reference to a lvalue.

** `static_cast` from a lvalue to a rvalue reference is permitted**. (ps: lvalue reference is a lvalue)

Special case: we can explicitly cast a lvalue to a rvalue reference using `static_cast`, even though we cannot implicitly convert a lvalue to a rvalue reference.

**Binding a rvalue reference to a lvalue gives code that operates on the rvalue reference permission to clobber the lvalue!**

#### 7. Variadic Templates
A variadic template is a template function or class that take a varying number of parameters. The varying parameters are known as a **parameter pack**.

Two kinds of parameter packs:

* A **template parameter pack** represents zero or more template parameters.
* A **function parameter pack** represents zero or more function parameters.

In a template parameter list, *`class...`* or *`typename...`* indicates that the following parameter represents a list of zero or more types; the name of a type followed by an ellipsis represents a list of zero or more nontype parameters of the given type.

In a function parameter list, a parameter whose type is a template parameter pack is a function parameter pack.

```C++
// Args is a template parameter pack; rest is a function parameter pack
// Args represents zero or more template type parameters
// rest represents zero or more function parameters
template <typename T, typename... Args>
void foo(const T& t, const Args&... rest);
```

Given the following call
```C++
int i = 0; double d = 2.1; string s = "hello world";
foo(i, s, 42, d);   // three parameters in the pack
foo(i, 42, "hi");   // two parameters in the pack
foo(d, s);          // one parameter in the pack
foo(s);             // zero parameter in the pack
```

The above calls will instantiate four different instances of `foo`
```C++
void foo(const int& t, const string&, const int&, const double&);
void foo(const int& t, const int&, const char[3]&);
void foo(const double& t, const string&);
void foo(const string& t);
```

##### 7.1 `sizeof...` operator

`sizeof...` returns a constant expression of how many elements there are in a pack and **does not evaluate its argument**.

##### 7.2 writing a variadic function template

Let's see an example
```C++
template<typename T>
std::ostream& iprint(std::ostream& os, const T& t)
{
    return os << t << std::endl;
}

template<typename T, typename... Args>
std::ostream& iprint(std::ostream& os, const T& t, const Args& ... rest)
{
    os << t << ", ";
    return iprint(os, rest...);
}
```

Variadic function templates are used when we know neither the number nor the types of the arguments we want to process.

Variadic functions are often recursive. The first call processes the first argument in the pack and calls itself on the remaining arguments:
```C++
template<typename T, typename... Args>
std::ostream& iprint(std::ostream& os, const T& t, const Args& ... rest)
```

To stop the recursion, we'll also need to define a nonvariadic function (the non-recursive case):
```C++
template<typename T>
std::ostream& iprint(std::ostream& os, const T& t)
```

Given:
```C++
iprint(std::cout, 23, 1.2, "hello");
```
The recursion will excutes as follows (pay attention to the instances of `iprint`:
```C++
iprint(std::ostream& os, const int& t, const double&, const char[6]&);  // t = 23, rest... = 1.2, "hello"
iprint(std::ostream& os, const double&, const char[6]&);                // t = 1.2, rest = "hello"
iprint(std::ostream& os, const char[6]&);                               // t = "hello"
```

For last call in the recursion, `iprint(std::cout, "hello")`, both variadic (a parameter pack can be empty) and nonvariadic versions of `iprint` are viable. Both functions provide an equally good match call. However, **a nonvariadic template is more specialized than a variadic template**, so the nonvariadic version is chosen for this call.

A declaration for the nonvariadic version of `iprint` must be in scope when the variadic version is defined. Otherwise, the variadic function will recurse indefinitely. (Test on VS2015, run correctly)

##### 7.3 Pack Expansion

Only two things we can do to a pack: `sizeof...` and `pack expansion`.

We trigger an expansion by putting `...` to the right of the pattern. And the pattern will apply to each element in the pack.
```C++
template<typename... Args>
std::ostream& errorMsg(std::ostream& os, const Args&... rest)   // expand Args
{
    return iprint(os, idebug(rest)...);                         // expand rest
}
```

The first expansion expands the template parameter pack and generates the function parameter list for `errorMsg`. The expansion of `Args` applies the pattern `const Args&` to each element in the template parameter pack `Args`. The expansion of this pattern is a comma-separated list of zero or more parameter types, each of which will have the form `const type&`. For example:
```C++
errorMsg(std::cout, 21, 22.3, string("hello")); // three parameters in the pack
```
This call is instantiated as
```C++
std::ostream& errorMsg(std::ostream& os, const int&, const double&, const string&);
```

The second expansion uses the pattern `idebug(rest)`. That pattern says that we want to call `idebug` on each element in the function parameter pack `rest`. The resulting expanded pack will be a comma-separated list of calls to `idebug`. That is, the above example will execute as if we had written:
```C++
iprint(os, idebug(21), idebug(22.3), idebug(string("hello")));
```

Pay attention to the difference between `idebug(rest)...` and `idebug(rest...)`. For `idebug(rest...)`, we expanded `rest` in the call to `idebug`. This call would execute as if we had written:
```C++
iprint(os, idebug(21, 22.3, string("hello")));
```

#### 8. Template specializations

##### 8.1 Defining a function template specialization

When we specialize a function template, we must **supply arguments for every template parameters in the orignial template**.
To indicate that we are specializing a template, we use `template <>`. The empty brackets indicate that arguments will be supplied for all the template parameters of the original template.

##### 8.2 Function overloading versus template specializations.
A specialization is an instantiation; it's not an overloaded instance of the function name. As a result, specializations don't affect function matching.

Templates and their specializations should be declared in the same header file. Declarations for all the templates with a given name should appear first, followed by any specializations of those templates.

##### 8.3 class template specializations
##### 8.4 class-template partial specializations
A class template specialization doesn't have to supply an argument for every template parameter. We can specify some of the template parameters or some aspects of the parameters. **A class template partial specialization is itself a template**. We must supply arguments for those template parameters that are not fixed by the specializations.
```C++
template<typename T> struct remove_reference
{
    typedef T type;
};
// partial specializations that will be used for lvalue reference - some aspect of the parameter
template<typename T> struct remove_reference<T&>
{
    typedef T type;
};
// partial specializatiions that will be used for rvalue reference - some aspect of the parameter.
template<typename T> struct remove_reference<T&&>
{
    typedef T type;
};

int i;
remove_reference<decltype(42)>::type a; // decltype(42) is int, use the original template
remove_reference<decltype(i)>::type b;  // decltype(i) is int&, use T& partial specialization
remove_reference<decltype(std::move(i))>::type c; // decltype(std::move(i)) is int&&, use T&& partial specialization
```

##### 8.5 specializing members but not class.
Rather than specializing the whole template, we can specialize just specific member function.
For example:
```C++
template<typename T> struct Foo{
    Foo(const T& t = T()) : mem(t) {}
    void Bar() {}
    T mem;
    // other members of Foo.
};

template<>              // we are specializing a template
void Foo<int>::Bar()    // we are specializing the Bar member of Foo<int>
{}
```