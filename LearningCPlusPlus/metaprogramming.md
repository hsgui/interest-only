# C++ template metaprogramming
#### 1. what's the spirit of metaprogramming

#### 2. Template parameters
###### 2.1 value parameter
###### 2.2 type parameter
###### 2.3 template template parameter

#### 3. function templates

#### 4. class templates
###### 4.1 template type alias
###### 4.2 using class members that are types

#### 5. Template compilation
###### 5.1 Controlling Instantiations

#### 6. Template Argument Deduction

#### 7. Variadic Templates
###### 7.1 `sizeof...` operator
###### 7.2 writing a variadic function template
###### 7.3 Pack expansion

#### 8. Template Specializations
###### 8.1 defining a function template specialization
###### 8.2 function overloading versus template specializations
###### 8.3 class template specializations
###### 8.4 class-template partial specializations
###### 8.5 specializing members but not the class

#### 1 spirit of metaprogramming
**All in one, template metaprogramming is all about types and works in compile time**.

Normally, programmers write code that is compiled and does something at run-time. While metaprogrammars write code that generates code at complile-time. Metaprogrammers use **metafunctions** to describe the code that generates code. That is, a function that takes types or non-type parameters as parameters and return a new type.

Template metaprogramming consists in **using the C++ template system to generate C++ types, and C++ code at compile-time**. A template function or class is not a function or class at all. It's a template to generate functions or classes. After instantiating the template with some types as argument, we get a new type or instance.

Take *std::vector* as an example. std::vector is not a class, is a template. We can instantiate std::vector with different element types to get new types. *`std::vector<int>`* is a new class type, *`std::vector<string>`* is another new class type, *`std::vector<double>`* is another new. These three new class types are generated by compiler at compile-time according to the *`std::vector`* template and managed internally by the compiler.

As metaprogramming, we actually work with C++ type system, using types as values for our computations. What's more, template metaprogramming works like a *functional programming language*. Because metafunctions have no side effect: **we can only create new types, not to modify existing ones**.

See [Introduction](http://blog.biicode.com/template-metaprogramming-with-modern-cpp-introduction/)

#### 2. Template parameters
C++ templates can take three kinds of parameters: **Value parameters**, **type parameters**, and **template template parameter**.

###### 2.1 value parameters
For value parameters (nontype parameters), C++ templates can only take parameters that are values known at compile time - constant expression. A nontype parameter may be an integral type, or a pointer, or reference to an object, or to a function type. An argument bound to a nontype integral parameter must be a constant expresion.

###### 2.2 type parameters
In general, we can use a type parameter as a type specifier in the same way that we use a built-in or class type specifier. In particular, a type parameter can be used to name the return type or a function parameter type, and for variable declarations or casts inside the function body.

###### 2.3 template template parameter
See [Template metaprogramming](http://blog.biicode.com/template-metaprogramming-cpp-ii/)

#### 3. Function templates
A function template can be declared *`inline`* or *`constexpr`* in the same way as nontemplate functions. The *`inline`* or *`constexpr`* specifier follows the template parameter list and precedes the return type:
```c++
template <typename T> inline T func(const T&);
```

#### 4. class templates
Class templates differ from function templates in that the **compiler cannot deduce the template parameter types for a class template**. Remember **the name of a class template is not the name of a type. A class template is used to instantiate a type, and an instantiated type always includes template argument(s)**.

By default, a member of an instantiated class template is instantiated only if the member is used. **The fact that members are instantiated only if we use them lets us instantiate a class with a type that may not meet the requirements for some of the template's operations**.

When we are inside the scope of a class template, the compiler treats references to the template itself as if we had supplied template arguments matching the template's own parameters.
```c++
template<typename T>
class Cla
{
public:
    Cla& operator++();
}
```
When we define members outside the body of a class template, we must remember that we are not in the scope of the class until the class name is seen. Inside the function body, we are in the scope of the class so do not need to repeat the template argument. When we do not supply template arguments, the compiler assumes that we are using the same type as the member's instantiation.
```c++
template<typename T>
Cla<T> Cla<T>::operator++(int)
{
    Cla ret = *this;
    ++*this;
    return ret;
}
```

###### 4.1 Template Type Alias
An instantiation of a class template defines a class type, and as with any other class type, we can define a `typedef` that refers to that instantiated class:
```C++
typedef Cla<int> IntCla;
```

Because a template is not a type, we cannot define a `typedef` that refers to a template.

However, we can use the following to define a type alias for a class template:
```C++
template<typename T> using twin = std::pair<T, T>;
typedef twin<int> IntPoint;     // IntPoint is a synonym for std::pair<int, int>
IntPoint p;

// std::vector is a template, std::vector<T>::size_type is a type.
typedef typename std::vector<T>::size_type SizeType;
SizeType index = SizeType();
```

When we define a template type alias, we can fix one or more of the template parameters:
```C++
template <typename T> using PartNo = std::pair<T, int>;
PartNo<string> books;       // books is a std::pair<string, int>
PartNo<Student> scores;     // scores is a std::pair<Student, int>
```

Note: template declarations must be in global, namespace or class scope, can't be in function scope.

###### 4.2 Using class members that are types
We can use scope operator (`::`) to access both *static members* and *type members*. In nontemplate code, the compiler has access to the class definition. As a result, it knows whether a name accessed through the scope operator is a type or a static member. For example when we write `std::string::size_type`, the compiler has the definition of `std::string` and can see that `size_type` is a type.

Assuming `T` is a template type parameter, when the compiler sees code such as `T::mem` it won't know until instantiation time whether `mem` is a type or a `static` data memeber. However, in order to process the template when no instantiations, the compiler must know whether a name represents a type. For example:
```C++
T::size_type* p;
```
Assuming `T` is the name of a type parameter, when the compiler sees a statement of that, it needs to know whether we're defining a variable named `p` or are multiplying a `static` data member named `size_type` by a variable named `p`.

By default, a name accessed through the scope operator (`::`) is not a type. As a result, if we want to use a type member of a template type parameter, we must explicitly tell the compiler that the name is a type using `typename`, not `class`. For example:
```C++
typename T::size_type *p;
```
We are defining a variable named `p`.

#### 5. Template compilation
When the compiler sees the definition of a template, it does not generate code. It generates code only when we instantiate a specific instance of the template. To generate an instantiation, the compiler needs to have the code that defines a function template or class template member function. **So definitions of function templates and member functions of class templates are ordinarily put into header files.**

**Compilation errors of templates are mostly reported during instantiation**

###### 5.1 controlling instantiations
The fact that instantiations are generated when a template is used means that the same instantiation may appear in multiple object files. When two or more separately compiled source files use the same template with the same template arguments, there is an instantiation of that template in each of those files. Then there is overhead of instantiating the same template in multiple files.

We can avoid this overhead through an **explicit instantiation**. An explicit instantiation contains two aspects: **instantiation declaration** and **instantiation definition**.
```C++
extern template declaration;    // instantiation declaration
template declaration;           // instantiation definition
```

```C++
extern template class Foo<int>; // instantiation declaration
extern template int compare(const int&, const int&); // instantiation declaration
```

When the compiler sees an `extern` template declaration, it willn't generate code for that instantiation in that file. Delcaring an instantiation as `extern` is a promise that there will be a nonextern use of that instantiation elsewhere in the program.

Because the compiler automatically instantiates a template when we use it, the `extern` declaration must appear before any code that uses that instantiation.

```C++
template class Foo<int>;    // instantiation definition
template int compare(const int&, const int&); // instantiation definition
```
When the compiler sees an instantiation definition, it generates code.

An **instantiation definition** for a class template instantiates **all** the members of that template including inline member functions. When the compiler see an instantiation definition it cannot know which member functions the program uses (the usage is in other source files). Hence, unlike the way the compiler handles ordinary class template instantiations, the compiler instantiates **all** the members of that class. Even if we do not use a member, that member will be instantiated. Consequently, we can use explicit instantiation **only for types that can be used with all the members of that template**

#### 6. Template Argument Deduction

#### 7. Variadic Templates
A variadic template is a template function or class that take a varying number of parameters. The varying parameters are known as a **parameter pack**.

Two kinds of parameter packs:

* A **template parameter pack** represents zero or more template parameters.
* A **function parameter pack** represents zero or more function parameters.

In a template parameter list, *`class...`* or *`typename...`* indicates that the following parameter represents a list of zero or more types; the name of a type followed by an ellipsis represents a list of zero or more nontype parameters of the given type.

In a function parameter list, a parameter whose type is a template parameter pack is a function parameter pack.

```C++
// Args is a template parameter pack; rest is a function parameter pack
// Args represents zero or more template type parameters
// rest represents zero or more function parameters
template <typename T, typename... Args>
void foo(const T& t, const Args&... rest);
```

Given the following call
```C++
int i = 0; double d = 2.1; string s = "hello world";
foo(i, s, 42, d);   // three parameters in the pack
foo(i, 42, "hi");   // two parameters in the pack
foo(d, s);          // one parameter in the pack
foo(s);             // zero parameter in the pack
```

The above calls will instantiate four different instances of `foo`
```C++
void foo(const int& t, const string&, const int&, const double&);
void foo(const int& t, const int&, const char[3]&);
void foo(const double& t, const string&);
void foo(const string& t);
```

###### 7.1 `sizeof...` operator

`sizeof...` returns a constant expression of how many elements there are in a pack and **does not evaluate its argument**.

###### 7.2 writing a variadic function template

Let's see an example
```C++
template<typename T>
std::ostream& iprint(std::ostream& os, const T& t)
{
    return os << t << std::endl;
}

template<typename T, typename... Args>
std::ostream& iprint(std::ostream& os, const T& t, const Args& ... rest)
{
    os << t << ", ";
    return iprint(os, rest...);
}
```

Variadic function templates are used when we know neither the number nor the types of the arguments we want to process.

Variadic functions are often recursive. The first call processes the first argument in the pack and calls itself on the remaining arguments:
```C++
template<typename T, typename... Args>
std::ostream& iprint(std::ostream& os, const T& t, const Args& ... rest)
```

To stop the recursion, we'll also need to define a nonvariadic function (the non-recursive case):
```C++
template<typename T>
std::ostream& iprint(std::ostream& os, const T& t)
```

Given:
```C++
iprint(std::cout, 23, 1.2, "hello");
```
The recursion will excutes as follows (pay attention to the instances of `iprint`:
```C++
iprint(std::ostream& os, const int& t, const double&, const char[6]&);  // t = 23, rest... = 1.2, "hello"
iprint(std::ostream& os, const double&, const char[6]&);                // t = 1.2, rest = "hello"
iprint(std::ostream& os, const char[6]&);                               // t = "hello"
```

For last call in the recursion, `iprint(std::cout, "hello")`, both variadic (a parameter pack can be empty) and nonvariadic versions of `iprint` are viable. Both functions provide an equally good match call. However, **a nonvariadic template is more specialized than a variadic template**, so the nonvariadic version is chosen for this call.

A declaration for the nonvariadic version of `iprint` must be in scope when the variadic version is defined. Otherwise, the variadic function will recurse indefinitely. (Test on VS2015, run correctly)

###### 7.3 Pack Expansion

Only two things we can do to a pack: `sizeof...` and `pack expansion`.

We trigger an expansion by putting `...` to the right of the pattern. And the pattern will apply to each element in the pack.
```C++
template<typename... Args>
std::ostream& errorMsg(std::ostream& os, const Args&... rest)   // expand Args
{
    return iprint(os, idebug(rest)...);                         // expand rest
}
```

The first expansion expands the template parameter pack and generates the function parameter list for `errorMsg`. The expansion of `Args` applies the pattern `const Args&` to each element in the template parameter pack `Args`. The expansion of this pattern is a comma-separated list of zero or more parameter types, each of which will have the form `const type&`. For example:
```C++
errorMsg(std::cout, 21, 22.3, string("hello")); // three parameters in the pack
```
This call is instantiated as
```C++
std::ostream& errorMsg(std::ostream& os, const int&, const double&, const string&);
```

The second expansion uses the pattern `idebug(rest)`. That pattern says that we want to call `idebug` on each element in the function parameter pack `rest`. The resulting expanded pack will be a comma-separated list of calls to `idebug`. That is, the above example will execute as if we had written:
```C++
iprint(os, idebug(21), idebug(22.3), idebug(string("hello")));
```

Pay attention to the difference between `idebug(rest)...` and `idebug(rest...)`. For `idebug(rest...)`, we expanded `rest` in the call to `idebug`. This call would execute as if we had written:
```C++
iprint(os, idebug(21, 22.3, string("hello")));
```

#### 8. Template specializations

###### 8.1 Defining a function template specialization

When we specialize a function template, we must **supply arguments for every template parameters in the orignial template**.
To indicate that we are specializing a template, we use `template <>`. The empty brackets indicate that arguments will be supplied for all the template parameters of the original template.

###### 8.2 Function overloading versus template specializations.
A specialization is an instantiation; it's not an overloaded instance of the function name. As a result, specializations don't affect function matching.

Templates and their specializations should be declared in the same header file. Declarations for all the templates with a given name should appear first, followed by any specializations of those templates.

###### 8.3 class template specializations
###### 8.4 class-template partial specializations
A class template specialization doesn't have to supply an argument for every template parameter. We can specify some of the template parameters or some aspects of the parameters. **A class template partial specialization is itself a template**. We must supply arguments for those template parameters that are not fixed by the specializations.
```C++
template<typename T> struct remove_reference
{
    typedef T type;
};
// partial specializations that will be used for lvalue reference - some aspect of the parameter
template<typename T> struct remove_reference<T&>
{
    typedef T type;
};
// partial specializatiions that will be used for rvalue reference - some aspect of the parameter.
template<typename T> struct remove_reference<T&&>
{
    typedef T type;
};

int i;
remove_reference<decltype(42)>::type a; // decltype(42) is int, use the original template
remove_reference<decltype(i)>::type b;  // decltype(i) is int&, use T& partial specialization
remove_reference<decltype(std::move(i))>::type c; // decltype(std::move(i)) is int&&, use T&& partial specialization
```

###### 8.5 specializing members but not class.
Rather than specializing the whole template, we can specialize just specific member function.
For example:
```C++
template<typename T> struct Foo{
    Foo(const T& t = T()) : mem(t) {}
    void Bar() {}
    T mem;
    // other members of Foo.
};

template<>              // we are specializing a template
void Foo<int>::Bar()    // we are specializing the Bar member of Foo<int>
{}
```